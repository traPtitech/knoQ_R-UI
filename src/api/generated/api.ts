/* tslint:disable */
/* eslint-disable */
/**
 * traP knoQ
 * This is a sample knoQ server. 
 *
 * The version of the OpenAPI document: 2.1.5
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddAllRoomsRequestInner
 */
export interface AddAllRoomsRequestInner {
    /**
     * 
     * @type {string}
     * @memberof AddAllRoomsRequestInner
     */
    'Subject'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddAllRoomsRequestInner
     */
    'Start date'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddAllRoomsRequestInner
     */
    'End date'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddAllRoomsRequestInner
     */
    'Start time'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddAllRoomsRequestInner
     */
    'End time'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddAllRoomsRequestInner
     */
    'Location'?: string;
}
/**
 * 
 * @export
 * @interface AuthParams
 */
export interface AuthParams {
    /**
     * 
     * @type {string}
     * @memberof AuthParams
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface Duration
 */
export interface Duration {
    /**
     * 
     * @type {string}
     * @memberof Duration
     */
    'timeStart': string;
    /**
     * 
     * @type {string}
     * @memberof Duration
     */
    'timeEnd': string;
}
/**
 * 
 * @export
 * @interface GetVersion200Response
 */
export interface GetVersion200Response {
    /**
     * 
     * @type {string}
     * @memberof GetVersion200Response
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetVersion200Response
     */
    'revision'?: string;
}
/**
 * 
 * @export
 * @interface IcalSecret
 */
export interface IcalSecret {
    /**
     * 
     * @type {string}
     * @memberof IcalSecret
     */
    'secret': string;
}
/**
 * @type RequestEvent
 * @export
 */
export type RequestEvent = RequestEventInstant | RequestEventStock;

/**
 * 部屋を作る
 * @export
 * @interface RequestEventInstant
 */
export interface RequestEventInstant {
    /**
     * 
     * @type {string}
     * @memberof RequestEventInstant
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RequestEventInstant
     */
    'description': string;
    /**
     * 部屋の共用をするか
     * @type {boolean}
     * @memberof RequestEventInstant
     */
    'sharedRoom': boolean;
    /**
     * 
     * @type {string}
     * @memberof RequestEventInstant
     */
    'timeStart': string;
    /**
     * 
     * @type {string}
     * @memberof RequestEventInstant
     */
    'timeEnd': string;
    /**
     * 
     * @type {string}
     * @memberof RequestEventInstant
     */
    'place': string;
    /**
     * 
     * @type {string}
     * @memberof RequestEventInstant
     */
    'groupId': string;
    /**
     * グループ外のユーザーが参加予定を出来るか
     * @type {boolean}
     * @memberof RequestEventInstant
     */
    'open'?: boolean;
    /**
     * 編集権を持つユーザー
     * @type {Array<string>}
     * @memberof RequestEventInstant
     */
    'admins': Array<string>;
    /**
     * 
     * @type {Array<RequestEventInstantTagsInner>}
     * @memberof RequestEventInstant
     */
    'tags'?: Array<RequestEventInstantTagsInner>;
}
/**
 * 
 * @export
 * @interface RequestEventInstantTagsInner
 */
export interface RequestEventInstantTagsInner {
    /**
     * 
     * @type {string}
     * @memberof RequestEventInstantTagsInner
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RequestEventInstantTagsInner
     */
    'locked'?: boolean;
}
/**
 * 既存の部屋を使う
 * @export
 * @interface RequestEventStock
 */
export interface RequestEventStock {
    /**
     * 
     * @type {string}
     * @memberof RequestEventStock
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RequestEventStock
     */
    'description': string;
    /**
     * 部屋の共用をするか
     * @type {boolean}
     * @memberof RequestEventStock
     */
    'sharedRoom': boolean;
    /**
     * 
     * @type {string}
     * @memberof RequestEventStock
     */
    'timeStart': string;
    /**
     * 
     * @type {string}
     * @memberof RequestEventStock
     */
    'timeEnd': string;
    /**
     * 
     * @type {string}
     * @memberof RequestEventStock
     */
    'roomId': string;
    /**
     * 
     * @type {string}
     * @memberof RequestEventStock
     */
    'groupId': string;
    /**
     * グループ外のユーザーが参加予定を出来るか
     * @type {boolean}
     * @memberof RequestEventStock
     */
    'open'?: boolean;
    /**
     * 編集権を持つユーザー
     * @type {Array<string>}
     * @memberof RequestEventStock
     */
    'admins': Array<string>;
    /**
     * 
     * @type {Array<RequestEventInstantTagsInner>}
     * @memberof RequestEventStock
     */
    'tags'?: Array<RequestEventInstantTagsInner>;
}
/**
 * 
 * @export
 * @interface RequestGroup
 */
export interface RequestGroup {
    /**
     * 
     * @type {string}
     * @memberof RequestGroup
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RequestGroup
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof RequestGroup
     */
    'open': boolean;
    /**
     * グループのメンバー
     * @type {Array<string>}
     * @memberof RequestGroup
     */
    'members'?: Array<string>;
    /**
     * 編集権を持つユーザー
     * @type {Array<string>}
     * @memberof RequestGroup
     */
    'admins': Array<string>;
}
/**
 * 
 * @export
 * @interface RequestRoom
 */
export interface RequestRoom {
    /**
     * 
     * @type {string}
     * @memberof RequestRoom
     */
    'place': string;
    /**
     * 
     * @type {string}
     * @memberof RequestRoom
     */
    'timeStart': string;
    /**
     * 
     * @type {string}
     * @memberof RequestRoom
     */
    'timeEnd': string;
    /**
     * 編集権を持つユーザー
     * @type {Array<string>}
     * @memberof RequestRoom
     */
    'admins': Array<string>;
}
/**
 * 
 * @export
 * @interface RequestSchedule
 */
export interface RequestSchedule {
    /**
     * pending or absent or attendance
     * @type {string}
     * @memberof RequestSchedule
     */
    'schedule': RequestScheduleScheduleEnum;
}

export const RequestScheduleScheduleEnum = {
    Pending: 'pending',
    Absent: 'absent',
    Attendance: 'attendance'
} as const;

export type RequestScheduleScheduleEnum = typeof RequestScheduleScheduleEnum[keyof typeof RequestScheduleScheduleEnum];

/**
 * 
 * @export
 * @interface RequestTag
 */
export interface RequestTag {
    /**
     * 
     * @type {string}
     * @memberof RequestTag
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ResponseEvent
 */
export interface ResponseEvent {
    /**
     * 
     * @type {string}
     * @memberof ResponseEvent
     */
    'eventId': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseEvent
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseEvent
     */
    'description': string;
    /**
     * 部屋の共用をするか
     * @type {boolean}
     * @memberof ResponseEvent
     */
    'sharedRoom': boolean;
    /**
     * 
     * @type {string}
     * @memberof ResponseEvent
     */
    'timeStart': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseEvent
     */
    'timeEnd': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseEvent
     */
    'place': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseEvent
     */
    'groupName': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseEvent
     */
    'roomId': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseEvent
     */
    'groupId': string;
    /**
     * グループ外のユーザーが参加予定を出来るか
     * @type {boolean}
     * @memberof ResponseEvent
     */
    'open': boolean;
    /**
     * 編集権を持つユーザー
     * @type {Array<string>}
     * @memberof ResponseEvent
     */
    'admins': Array<string>;
    /**
     * 
     * @type {Array<ResponseEventTagsInner>}
     * @memberof ResponseEvent
     */
    'tags': Array<ResponseEventTagsInner>;
    /**
     * 
     * @type {Array<ResponseEventAttendeesInner>}
     * @memberof ResponseEvent
     */
    'attendees': Array<ResponseEventAttendeesInner>;
    /**
     * 
     * @type {string}
     * @memberof ResponseEvent
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseEvent
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseEvent
     */
    'updatedAt': string;
}
/**
 * ユーザの参加状況
 * @export
 * @interface ResponseEventAttendeesInner
 */
export interface ResponseEventAttendeesInner {
    /**
     * 
     * @type {string}
     * @memberof ResponseEventAttendeesInner
     */
    'userId': string;
    /**
     * pending or absent or attendance
     * @type {string}
     * @memberof ResponseEventAttendeesInner
     */
    'schedule': ResponseEventAttendeesInnerScheduleEnum;
}

export const ResponseEventAttendeesInnerScheduleEnum = {
    Pending: 'pending',
    Absent: 'absent',
    Attendance: 'attendance'
} as const;

export type ResponseEventAttendeesInnerScheduleEnum = typeof ResponseEventAttendeesInnerScheduleEnum[keyof typeof ResponseEventAttendeesInnerScheduleEnum];

/**
 * 
 * @export
 * @interface ResponseEventDetail
 */
export interface ResponseEventDetail {
    /**
     * 
     * @type {string}
     * @memberof ResponseEventDetail
     */
    'eventId': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseEventDetail
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseEventDetail
     */
    'description': string;
    /**
     * 部屋の共用をするか
     * @type {boolean}
     * @memberof ResponseEventDetail
     */
    'sharedRoom': boolean;
    /**
     * 
     * @type {string}
     * @memberof ResponseEventDetail
     */
    'timeStart': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseEventDetail
     */
    'timeEnd': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseEventDetail
     */
    'place': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseEventDetail
     */
    'groupName': string;
    /**
     * グループ外のユーザーが参加予定を出来るか
     * @type {boolean}
     * @memberof ResponseEventDetail
     */
    'open': boolean;
    /**
     * 
     * @type {ResponseRoom}
     * @memberof ResponseEventDetail
     */
    'room': ResponseRoom;
    /**
     * 
     * @type {ResponseGroup}
     * @memberof ResponseEventDetail
     */
    'group': ResponseGroup;
    /**
     * 編集権を持つユーザー
     * @type {Array<string>}
     * @memberof ResponseEventDetail
     */
    'admins': Array<string>;
    /**
     * 
     * @type {Array<ResponseEventTagsInner>}
     * @memberof ResponseEventDetail
     */
    'tags': Array<ResponseEventTagsInner>;
    /**
     * 
     * @type {Array<ResponseEventAttendeesInner>}
     * @memberof ResponseEventDetail
     */
    'attendees': Array<ResponseEventAttendeesInner>;
    /**
     * 
     * @type {string}
     * @memberof ResponseEventDetail
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseEventDetail
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseEventDetail
     */
    'updatedAt': string;
}
/**
 * タグの配列
 * @export
 * @interface ResponseEventTagsInner
 */
export interface ResponseEventTagsInner {
    /**
     * 
     * @type {string}
     * @memberof ResponseEventTagsInner
     */
    'tagId': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseEventTagsInner
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseEventTagsInner
     */
    'locked'?: boolean;
}
/**
 * 
 * @export
 * @interface ResponseGroup
 */
export interface ResponseGroup {
    /**
     * 
     * @type {string}
     * @memberof ResponseGroup
     */
    'groupId': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseGroup
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseGroup
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseGroup
     */
    'open': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseGroup
     */
    'isTraQGroup': boolean;
    /**
     * グループのメンバー
     * @type {Array<string>}
     * @memberof ResponseGroup
     */
    'members': Array<string>;
    /**
     * 編集権を持つユーザー
     * @type {Array<string>}
     * @memberof ResponseGroup
     */
    'admins': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ResponseGroup
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseGroup
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseGroup
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface ResponseRoom
 */
export interface ResponseRoom {
    /**
     * 
     * @type {string}
     * @memberof ResponseRoom
     */
    'roomId': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseRoom
     */
    'place': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseRoom
     */
    'timeStart': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseRoom
     */
    'timeEnd': string;
    /**
     * 部屋が使えることを保証する
     * @type {boolean}
     * @memberof ResponseRoom
     */
    'verified': boolean;
    /**
     * どのイベントも使用していない時間帯
     * @type {Array<Duration>}
     * @memberof ResponseRoom
     */
    'freeTimes': Array<Duration>;
    /**
     * 部屋を共用すれば、使用できる時間帯
     * @type {Array<Duration>}
     * @memberof ResponseRoom
     */
    'sharedTimes': Array<Duration>;
    /**
     * 編集権を持つユーザー
     * @type {Array<string>}
     * @memberof ResponseRoom
     */
    'admins': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ResponseRoom
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseRoom
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseRoom
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface ResponseTag
 */
export interface ResponseTag {
    /**
     * 
     * @type {string}
     * @memberof ResponseTag
     */
    'tagId': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseTag
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseTag
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseTag
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface ResponseUser
 */
export interface ResponseUser {
    /**
     * 
     * @type {string}
     * @memberof ResponseUser
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseUser
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseUser
     */
    'displayName': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseUser
     */
    'icon': string;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseUser
     */
    'privileged': boolean;
    /**
     * ユーザーアカウント状態 0: 停止 1: 有効 2: 一時停止
     * @type {number}
     * @memberof ResponseUser
     */
    'state': number;
}

/**
 * ActivityApi - axios parameter creator
 * @export
 */
export const ActivityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 最近7日間に作成変更削除があったイベントを取得。 削除されたものを含んで返す。 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getEventActivities: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/activity/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityApi - functional programming interface
 * @export
 */
export const ActivityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivityApiAxiosParamCreator(configuration)
    return {
        /**
         * 最近7日間に作成変更削除があったイベントを取得。 削除されたものを含んで返す。 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getEventActivities(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResponseEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventActivities(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActivityApi - factory interface
 * @export
 */
export const ActivityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivityApiFp(configuration)
    return {
        /**
         * 最近7日間に作成変更削除があったイベントを取得。 削除されたものを含んで返す。 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getEventActivities(options?: any): AxiosPromise<Array<ResponseEvent>> {
            return localVarFp.getEventActivities(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivityApi - object-oriented interface
 * @export
 * @class ActivityApi
 * @extends {BaseAPI}
 */
export class ActivityApi extends BaseAPI {
    /**
     * 最近7日間に作成変更削除があったイベントを取得。 削除されたものを含んで返す。 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public getEventActivities(options?: AxiosRequestConfig) {
        return ActivityApiFp(this.configuration).getEventActivities(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * リクエストに必要な情報を返す
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authParams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * コールバックを検知して、トークンを取得します。
         * @param {string} session 
         * @param {string} code OAuth2.0のcode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallback: async (session: string, code: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'session' is not null or undefined
            assertParamExists('getCallback', 'session', session)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('getCallback', 'code', code)
            const localVarPath = `/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * リクエストに必要な情報を返す
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthParams(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthParams>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * コールバックを検知して、トークンを取得します。
         * @param {string} session 
         * @param {string} code OAuth2.0のcode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCallback(session: string, code: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCallback(session, code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * リクエストに必要な情報を返す
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthParams(options?: any): AxiosPromise<AuthParams> {
            return localVarFp.getAuthParams(options).then((request) => request(axios, basePath));
        },
        /**
         * コールバックを検知して、トークンを取得します。
         * @param {string} session 
         * @param {string} code OAuth2.0のcode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallback(session: string, code: string, options?: any): AxiosPromise<void> {
            return localVarFp.getCallback(session, code, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * リクエストに必要な情報を返す
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getAuthParams(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getAuthParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * コールバックを検知して、トークンを取得します。
     * @param {string} session 
     * @param {string} code OAuth2.0のcode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getCallback(session: string, code: string, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getCallback(session, code, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * タグを追加
         * @summary タグを追加
         * @param {string} eventID 
         * @param {RequestTag} requestTag イベントにタグを追加
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEventTag: async (eventID: string, requestTag: RequestTag, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventID' is not null or undefined
            assertParamExists('addEventTag', 'eventID', eventID)
            // verify required parameter 'requestTag' is not null or undefined
            assertParamExists('addEventTag', 'requestTag', requestTag)
            const localVarPath = `/events/{eventID}/tags`
                .replace(`{${"eventID"}}`, encodeURIComponent(String(eventID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestTag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 部屋の使用宣言を行う
         * @summary 部屋の使用宣言を行う
         * @param {RequestEvent} requestEvent 予約の編集
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEvents: async (requestEvent: RequestEvent, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestEvent' is not null or undefined
            assertParamExists('addEvents', 'requestEvent', requestEvent)
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEvent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * adminsのみ
         * @summary 使用宣言を削除
         * @param {string} eventID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent: async (eventID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventID' is not null or undefined
            assertParamExists('deleteEvent', 'eventID', eventID)
            const localVarPath = `/events/{eventID}`
                .replace(`{${"eventID"}}`, encodeURIComponent(String(eventID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * locked=falseだけ
         * @summary タグを削除
         * @param {string} eventID 
         * @param {string} tagName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventTag: async (eventID: string, tagName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventID' is not null or undefined
            assertParamExists('deleteEventTag', 'eventID', eventID)
            // verify required parameter 'tagName' is not null or undefined
            assertParamExists('deleteEventTag', 'tagName', tagName)
            const localVarPath = `/events/{eventID}/tags/{tagName}`
                .replace(`{${"eventID"}}`, encodeURIComponent(String(eventID)))
                .replace(`{${"tagName"}}`, encodeURIComponent(String(tagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 最近7日間に作成変更削除があったイベントを取得。 削除されたものを含んで返す。 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getEventActivities: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/activity/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 一件取得
         * @summary 一件取得
         * @param {string} eventID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventDetail: async (eventID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventID' is not null or undefined
            assertParamExists('getEventDetail', 'eventID', eventID)
            const localVarPath = `/events/{eventID}`
                .replace(`{${"eventID"}}`, encodeURIComponent(String(eventID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 使用宣言の情報を取得
         * @summary 使用宣言の情報を取得
         * @param {string} [dateBegin] 特定の日時から。
         * @param {string} [dateEnd] 特定の日時まで。
         * @param {string} [q] Syntax: &lt;br&gt; top  : ε | expr, expr : term ( ( \&quot;||\&quot; | \&quot;&amp;&amp;\&quot; ) term)*&lt;br&gt; term : cmp | \&quot;(\&quot; expr \&quot;)\&quot;&lt;br&gt; cmp  : Attr ( \&quot;&#x3D;&#x3D;\&quot; | \&quot;!&#x3D;\&quot; ) UUID&lt;br&gt; Attr : \&quot;event\&quot; | \&quot;user\&quot; | \&quot;group\&quot; | \&quot;tag\&quot; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (dateBegin?: string, dateEnd?: string, q?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dateBegin !== undefined) {
                localVarQueryParameter['dateBegin'] = dateBegin;
            }

            if (dateEnd !== undefined) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * groupIdのeventsを取得
         * @param {string} groupID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsOfGroup: async (groupID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupID' is not null or undefined
            assertParamExists('getEventsOfGroup', 'groupID', groupID)
            const localVarPath = `/groups/{groupID}/events`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定した部屋で行われるイベントを返す
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsOfRoom: async (roomID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('getEventsOfRoom', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/events`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 所属しているイベントを返す
         * @param {'admins' | 'belongs' | 'attendees'} [relation] どのような関係性でユーザーと結びつけるか。| 取り得る値は、admins(ユーザーが管理者), belongs(ユーザーが所属している) | イベントはさらに、attendees(not absent)| 値がない場合は、belongs として振る舞う
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyEvents: async (relation?: 'admins' | 'belongs' | 'attendees', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (relation !== undefined) {
                localVarQueryParameter['relation'] = relation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 所属しているイベントを返す
         * @param {string} userID 
         * @param {'admins' | 'belongs' | 'attendees'} [relation] どのような関係性でユーザーと結びつけるか。| 取り得る値は、admins(ユーザーが管理者), belongs(ユーザーが所属している) | イベントはさらに、attendees(not absent)| 値がない場合は、belongs として振る舞う
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEvents: async (userID: string, relation?: 'admins' | 'belongs' | 'attendees', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('getUserEvents', 'userID', userID)
            const localVarPath = `/users/{userID}/events`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (relation !== undefined) {
                localVarQueryParameter['relation'] = relation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * adminsのみ
         * @summary 部屋の使用宣言を更新
         * @param {string} eventID 
         * @param {RequestEvent} requestEvent 予約の編集
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent: async (eventID: string, requestEvent: RequestEvent, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventID' is not null or undefined
            assertParamExists('updateEvent', 'eventID', eventID)
            // verify required parameter 'requestEvent' is not null or undefined
            assertParamExists('updateEvent', 'requestEvent', requestEvent)
            const localVarPath = `/events/{eventID}`
                .replace(`{${"eventID"}}`, encodeURIComponent(String(eventID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEvent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 自分の参加予定を編集
         * @param {string} eventID 
         * @param {RequestSchedule} requestSchedule イベントの参加予定を更新
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchedule: async (eventID: string, requestSchedule: RequestSchedule, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventID' is not null or undefined
            assertParamExists('updateSchedule', 'eventID', eventID)
            // verify required parameter 'requestSchedule' is not null or undefined
            assertParamExists('updateSchedule', 'requestSchedule', requestSchedule)
            const localVarPath = `/events/{eventID}/attendees/me`
                .replace(`{${"eventID"}}`, encodeURIComponent(String(eventID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestSchedule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * タグを追加
         * @summary タグを追加
         * @param {string} eventID 
         * @param {RequestTag} requestTag イベントにタグを追加
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addEventTag(eventID: string, requestTag: RequestTag, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addEventTag(eventID, requestTag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 部屋の使用宣言を行う
         * @summary 部屋の使用宣言を行う
         * @param {RequestEvent} requestEvent 予約の編集
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addEvents(requestEvent: RequestEvent, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseEventDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addEvents(requestEvent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * adminsのみ
         * @summary 使用宣言を削除
         * @param {string} eventID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEvent(eventID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEvent(eventID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * locked=falseだけ
         * @summary タグを削除
         * @param {string} eventID 
         * @param {string} tagName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventTag(eventID: string, tagName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventTag(eventID, tagName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 最近7日間に作成変更削除があったイベントを取得。 削除されたものを含んで返す。 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getEventActivities(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResponseEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventActivities(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 一件取得
         * @summary 一件取得
         * @param {string} eventID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventDetail(eventID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseEventDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventDetail(eventID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 使用宣言の情報を取得
         * @summary 使用宣言の情報を取得
         * @param {string} [dateBegin] 特定の日時から。
         * @param {string} [dateEnd] 特定の日時まで。
         * @param {string} [q] Syntax: &lt;br&gt; top  : ε | expr, expr : term ( ( \&quot;||\&quot; | \&quot;&amp;&amp;\&quot; ) term)*&lt;br&gt; term : cmp | \&quot;(\&quot; expr \&quot;)\&quot;&lt;br&gt; cmp  : Attr ( \&quot;&#x3D;&#x3D;\&quot; | \&quot;!&#x3D;\&quot; ) UUID&lt;br&gt; Attr : \&quot;event\&quot; | \&quot;user\&quot; | \&quot;group\&quot; | \&quot;tag\&quot; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(dateBegin?: string, dateEnd?: string, q?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResponseEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(dateBegin, dateEnd, q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * groupIdのeventsを取得
         * @param {string} groupID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventsOfGroup(groupID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResponseEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventsOfGroup(groupID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 指定した部屋で行われるイベントを返す
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventsOfRoom(roomID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResponseEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventsOfRoom(roomID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 所属しているイベントを返す
         * @param {'admins' | 'belongs' | 'attendees'} [relation] どのような関係性でユーザーと結びつけるか。| 取り得る値は、admins(ユーザーが管理者), belongs(ユーザーが所属している) | イベントはさらに、attendees(not absent)| 値がない場合は、belongs として振る舞う
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyEvents(relation?: 'admins' | 'belongs' | 'attendees', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResponseEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyEvents(relation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 所属しているイベントを返す
         * @param {string} userID 
         * @param {'admins' | 'belongs' | 'attendees'} [relation] どのような関係性でユーザーと結びつけるか。| 取り得る値は、admins(ユーザーが管理者), belongs(ユーザーが所属している) | イベントはさらに、attendees(not absent)| 値がない場合は、belongs として振る舞う
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserEvents(userID: string, relation?: 'admins' | 'belongs' | 'attendees', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResponseEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserEvents(userID, relation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * adminsのみ
         * @summary 部屋の使用宣言を更新
         * @param {string} eventID 
         * @param {RequestEvent} requestEvent 予約の編集
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEvent(eventID: string, requestEvent: RequestEvent, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseEventDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvent(eventID, requestEvent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 自分の参加予定を編集
         * @param {string} eventID 
         * @param {RequestSchedule} requestSchedule イベントの参加予定を更新
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSchedule(eventID: string, requestSchedule: RequestSchedule, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSchedule(eventID, requestSchedule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * タグを追加
         * @summary タグを追加
         * @param {string} eventID 
         * @param {RequestTag} requestTag イベントにタグを追加
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEventTag(eventID: string, requestTag: RequestTag, options?: any): AxiosPromise<void> {
            return localVarFp.addEventTag(eventID, requestTag, options).then((request) => request(axios, basePath));
        },
        /**
         * 部屋の使用宣言を行う
         * @summary 部屋の使用宣言を行う
         * @param {RequestEvent} requestEvent 予約の編集
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEvents(requestEvent: RequestEvent, options?: any): AxiosPromise<ResponseEventDetail> {
            return localVarFp.addEvents(requestEvent, options).then((request) => request(axios, basePath));
        },
        /**
         * adminsのみ
         * @summary 使用宣言を削除
         * @param {string} eventID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(eventID: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEvent(eventID, options).then((request) => request(axios, basePath));
        },
        /**
         * locked=falseだけ
         * @summary タグを削除
         * @param {string} eventID 
         * @param {string} tagName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventTag(eventID: string, tagName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEventTag(eventID, tagName, options).then((request) => request(axios, basePath));
        },
        /**
         * 最近7日間に作成変更削除があったイベントを取得。 削除されたものを含んで返す。 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getEventActivities(options?: any): AxiosPromise<Array<ResponseEvent>> {
            return localVarFp.getEventActivities(options).then((request) => request(axios, basePath));
        },
        /**
         * 一件取得
         * @summary 一件取得
         * @param {string} eventID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventDetail(eventID: string, options?: any): AxiosPromise<ResponseEventDetail> {
            return localVarFp.getEventDetail(eventID, options).then((request) => request(axios, basePath));
        },
        /**
         * 使用宣言の情報を取得
         * @summary 使用宣言の情報を取得
         * @param {string} [dateBegin] 特定の日時から。
         * @param {string} [dateEnd] 特定の日時まで。
         * @param {string} [q] Syntax: &lt;br&gt; top  : ε | expr, expr : term ( ( \&quot;||\&quot; | \&quot;&amp;&amp;\&quot; ) term)*&lt;br&gt; term : cmp | \&quot;(\&quot; expr \&quot;)\&quot;&lt;br&gt; cmp  : Attr ( \&quot;&#x3D;&#x3D;\&quot; | \&quot;!&#x3D;\&quot; ) UUID&lt;br&gt; Attr : \&quot;event\&quot; | \&quot;user\&quot; | \&quot;group\&quot; | \&quot;tag\&quot; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(dateBegin?: string, dateEnd?: string, q?: string, options?: any): AxiosPromise<Array<ResponseEvent>> {
            return localVarFp.getEvents(dateBegin, dateEnd, q, options).then((request) => request(axios, basePath));
        },
        /**
         * groupIdのeventsを取得
         * @param {string} groupID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsOfGroup(groupID: string, options?: any): AxiosPromise<Array<ResponseEvent>> {
            return localVarFp.getEventsOfGroup(groupID, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定した部屋で行われるイベントを返す
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsOfRoom(roomID: string, options?: any): AxiosPromise<Array<ResponseEvent>> {
            return localVarFp.getEventsOfRoom(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 所属しているイベントを返す
         * @param {'admins' | 'belongs' | 'attendees'} [relation] どのような関係性でユーザーと結びつけるか。| 取り得る値は、admins(ユーザーが管理者), belongs(ユーザーが所属している) | イベントはさらに、attendees(not absent)| 値がない場合は、belongs として振る舞う
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyEvents(relation?: 'admins' | 'belongs' | 'attendees', options?: any): AxiosPromise<Array<ResponseEvent>> {
            return localVarFp.getMyEvents(relation, options).then((request) => request(axios, basePath));
        },
        /**
         * 所属しているイベントを返す
         * @param {string} userID 
         * @param {'admins' | 'belongs' | 'attendees'} [relation] どのような関係性でユーザーと結びつけるか。| 取り得る値は、admins(ユーザーが管理者), belongs(ユーザーが所属している) | イベントはさらに、attendees(not absent)| 値がない場合は、belongs として振る舞う
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEvents(userID: string, relation?: 'admins' | 'belongs' | 'attendees', options?: any): AxiosPromise<Array<ResponseEvent>> {
            return localVarFp.getUserEvents(userID, relation, options).then((request) => request(axios, basePath));
        },
        /**
         * adminsのみ
         * @summary 部屋の使用宣言を更新
         * @param {string} eventID 
         * @param {RequestEvent} requestEvent 予約の編集
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent(eventID: string, requestEvent: RequestEvent, options?: any): AxiosPromise<ResponseEventDetail> {
            return localVarFp.updateEvent(eventID, requestEvent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 自分の参加予定を編集
         * @param {string} eventID 
         * @param {RequestSchedule} requestSchedule イベントの参加予定を更新
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchedule(eventID: string, requestSchedule: RequestSchedule, options?: any): AxiosPromise<void> {
            return localVarFp.updateSchedule(eventID, requestSchedule, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * タグを追加
     * @summary タグを追加
     * @param {string} eventID 
     * @param {RequestTag} requestTag イベントにタグを追加
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public addEventTag(eventID: string, requestTag: RequestTag, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).addEventTag(eventID, requestTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 部屋の使用宣言を行う
     * @summary 部屋の使用宣言を行う
     * @param {RequestEvent} requestEvent 予約の編集
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public addEvents(requestEvent: RequestEvent, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).addEvents(requestEvent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * adminsのみ
     * @summary 使用宣言を削除
     * @param {string} eventID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public deleteEvent(eventID: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).deleteEvent(eventID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * locked=falseだけ
     * @summary タグを削除
     * @param {string} eventID 
     * @param {string} tagName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public deleteEventTag(eventID: string, tagName: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).deleteEventTag(eventID, tagName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 最近7日間に作成変更削除があったイベントを取得。 削除されたものを含んで返す。 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEventActivities(options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEventActivities(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 一件取得
     * @summary 一件取得
     * @param {string} eventID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEventDetail(eventID: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEventDetail(eventID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 使用宣言の情報を取得
     * @summary 使用宣言の情報を取得
     * @param {string} [dateBegin] 特定の日時から。
     * @param {string} [dateEnd] 特定の日時まで。
     * @param {string} [q] Syntax: &lt;br&gt; top  : ε | expr, expr : term ( ( \&quot;||\&quot; | \&quot;&amp;&amp;\&quot; ) term)*&lt;br&gt; term : cmp | \&quot;(\&quot; expr \&quot;)\&quot;&lt;br&gt; cmp  : Attr ( \&quot;&#x3D;&#x3D;\&quot; | \&quot;!&#x3D;\&quot; ) UUID&lt;br&gt; Attr : \&quot;event\&quot; | \&quot;user\&quot; | \&quot;group\&quot; | \&quot;tag\&quot; 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEvents(dateBegin?: string, dateEnd?: string, q?: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEvents(dateBegin, dateEnd, q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * groupIdのeventsを取得
     * @param {string} groupID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEventsOfGroup(groupID: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEventsOfGroup(groupID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定した部屋で行われるイベントを返す
     * @param {string} roomID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEventsOfRoom(roomID: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEventsOfRoom(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 所属しているイベントを返す
     * @param {'admins' | 'belongs' | 'attendees'} [relation] どのような関係性でユーザーと結びつけるか。| 取り得る値は、admins(ユーザーが管理者), belongs(ユーザーが所属している) | イベントはさらに、attendees(not absent)| 値がない場合は、belongs として振る舞う
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getMyEvents(relation?: 'admins' | 'belongs' | 'attendees', options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).getMyEvents(relation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 所属しているイベントを返す
     * @param {string} userID 
     * @param {'admins' | 'belongs' | 'attendees'} [relation] どのような関係性でユーザーと結びつけるか。| 取り得る値は、admins(ユーザーが管理者), belongs(ユーザーが所属している) | イベントはさらに、attendees(not absent)| 値がない場合は、belongs として振る舞う
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getUserEvents(userID: string, relation?: 'admins' | 'belongs' | 'attendees', options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).getUserEvents(userID, relation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * adminsのみ
     * @summary 部屋の使用宣言を更新
     * @param {string} eventID 
     * @param {RequestEvent} requestEvent 予約の編集
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateEvent(eventID: string, requestEvent: RequestEvent, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).updateEvent(eventID, requestEvent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 自分の参加予定を編集
     * @param {string} eventID 
     * @param {RequestSchedule} requestSchedule イベントの参加予定を更新
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateSchedule(eventID: string, requestSchedule: RequestSchedule, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).updateSchedule(eventID, requestSchedule, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 自分をメンバーに追加する
         * @summary 自分を追加。open=true
         * @param {string} groupID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMeToGroup: async (groupID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupID' is not null or undefined
            assertParamExists('addMeToGroup', 'groupID', groupID)
            const localVarPath = `/groups/{groupID}/members/me`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * グループを作成します。traQのグループとは無関係です。
         * @summary グループ作成
         * @param {RequestGroup} requestGroup グループの追加
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (requestGroup: RequestGroup, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestGroup' is not null or undefined
            assertParamExists('createGroup', 'requestGroup', requestGroup)
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * グループの削除
         * @summary Delete group
         * @param {string} groupID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (groupID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupID' is not null or undefined
            assertParamExists('deleteGroup', 'groupID', groupID)
            const localVarPath = `/groups/{groupID}`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分しか削除出来ない。open=true
         * @summary 自分しか削除出来ない。open=true
         * @param {string} groupID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMeFromGroup: async (groupID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupID' is not null or undefined
            assertParamExists('deleteMeFromGroup', 'groupID', groupID)
            const localVarPath = `/groups/{groupID}/members/me`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 一件取得
         * @summary 一件取得
         * @param {string} groupID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: async (groupID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupID' is not null or undefined
            assertParamExists('getGroup', 'groupID', groupID)
            const localVarPath = `/groups/{groupID}`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * すべてのグループを取得する
         * @summary グループを全て取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分の所属しているグループのIDを返す
         * @param {'admins' | 'belongs' | 'attendees'} [relation] どのような関係性でユーザーと結びつけるか。| 取り得る値は、admins(ユーザーが管理者), belongs(ユーザーが所属している) | イベントはさらに、attendees(not absent)| 値がない場合は、belongs として振る舞う
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyGroups: async (relation?: 'admins' | 'belongs' | 'attendees', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (relation !== undefined) {
                localVarQueryParameter['relation'] = relation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーが所属しているグループのIDを返す
         * @param {string} userID 
         * @param {'admins' | 'belongs' | 'attendees'} [relation] どのような関係性でユーザーと結びつけるか。| 取り得る値は、admins(ユーザーが管理者), belongs(ユーザーが所属している) | イベントはさらに、attendees(not absent)| 値がない場合は、belongs として振る舞う
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups: async (userID: string, relation?: 'admins' | 'belongs' | 'attendees', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('getUserGroups', 'userID', userID)
            const localVarPath = `/users/{userID}/groups`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (relation !== undefined) {
                localVarQueryParameter['relation'] = relation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * adminsのみ変更可能
         * @param {string} groupID 
         * @param {RequestGroup} requestGroup グループの追加
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup: async (groupID: string, requestGroup: RequestGroup, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupID' is not null or undefined
            assertParamExists('updateGroup', 'groupID', groupID)
            // verify required parameter 'requestGroup' is not null or undefined
            assertParamExists('updateGroup', 'requestGroup', requestGroup)
            const localVarPath = `/groups/{groupID}`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 自分をメンバーに追加する
         * @summary 自分を追加。open=true
         * @param {string} groupID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMeToGroup(groupID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMeToGroup(groupID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * グループを作成します。traQのグループとは無関係です。
         * @summary グループ作成
         * @param {RequestGroup} requestGroup グループの追加
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(requestGroup: RequestGroup, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(requestGroup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * グループの削除
         * @summary Delete group
         * @param {string} groupID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(groupID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(groupID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 自分しか削除出来ない。open=true
         * @summary 自分しか削除出来ない。open=true
         * @param {string} groupID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMeFromGroup(groupID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMeFromGroup(groupID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 一件取得
         * @summary 一件取得
         * @param {string} groupID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroup(groupID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroup(groupID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * すべてのグループを取得する
         * @summary グループを全て取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroups(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResponseGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 自分の所属しているグループのIDを返す
         * @param {'admins' | 'belongs' | 'attendees'} [relation] どのような関係性でユーザーと結びつけるか。| 取り得る値は、admins(ユーザーが管理者), belongs(ユーザーが所属している) | イベントはさらに、attendees(not absent)| 値がない場合は、belongs として振る舞う
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyGroups(relation?: 'admins' | 'belongs' | 'attendees', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyGroups(relation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ユーザーが所属しているグループのIDを返す
         * @param {string} userID 
         * @param {'admins' | 'belongs' | 'attendees'} [relation] どのような関係性でユーザーと結びつけるか。| 取り得る値は、admins(ユーザーが管理者), belongs(ユーザーが所属している) | イベントはさらに、attendees(not absent)| 値がない場合は、belongs として振る舞う
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserGroups(userID: string, relation?: 'admins' | 'belongs' | 'attendees', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserGroups(userID, relation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * adminsのみ変更可能
         * @param {string} groupID 
         * @param {RequestGroup} requestGroup グループの追加
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroup(groupID: string, requestGroup: RequestGroup, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroup(groupID, requestGroup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * 自分をメンバーに追加する
         * @summary 自分を追加。open=true
         * @param {string} groupID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMeToGroup(groupID: string, options?: any): AxiosPromise<void> {
            return localVarFp.addMeToGroup(groupID, options).then((request) => request(axios, basePath));
        },
        /**
         * グループを作成します。traQのグループとは無関係です。
         * @summary グループ作成
         * @param {RequestGroup} requestGroup グループの追加
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(requestGroup: RequestGroup, options?: any): AxiosPromise<ResponseGroup> {
            return localVarFp.createGroup(requestGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * グループの削除
         * @summary Delete group
         * @param {string} groupID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupID: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroup(groupID, options).then((request) => request(axios, basePath));
        },
        /**
         * 自分しか削除出来ない。open=true
         * @summary 自分しか削除出来ない。open=true
         * @param {string} groupID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMeFromGroup(groupID: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMeFromGroup(groupID, options).then((request) => request(axios, basePath));
        },
        /**
         * 一件取得
         * @summary 一件取得
         * @param {string} groupID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupID: string, options?: any): AxiosPromise<ResponseGroup> {
            return localVarFp.getGroup(groupID, options).then((request) => request(axios, basePath));
        },
        /**
         * すべてのグループを取得する
         * @summary グループを全て取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(options?: any): AxiosPromise<Array<ResponseGroup>> {
            return localVarFp.getGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * 自分の所属しているグループのIDを返す
         * @param {'admins' | 'belongs' | 'attendees'} [relation] どのような関係性でユーザーと結びつけるか。| 取り得る値は、admins(ユーザーが管理者), belongs(ユーザーが所属している) | イベントはさらに、attendees(not absent)| 値がない場合は、belongs として振る舞う
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyGroups(relation?: 'admins' | 'belongs' | 'attendees', options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getMyGroups(relation, options).then((request) => request(axios, basePath));
        },
        /**
         * ユーザーが所属しているグループのIDを返す
         * @param {string} userID 
         * @param {'admins' | 'belongs' | 'attendees'} [relation] どのような関係性でユーザーと結びつけるか。| 取り得る値は、admins(ユーザーが管理者), belongs(ユーザーが所属している) | イベントはさらに、attendees(not absent)| 値がない場合は、belongs として振る舞う
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups(userID: string, relation?: 'admins' | 'belongs' | 'attendees', options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getUserGroups(userID, relation, options).then((request) => request(axios, basePath));
        },
        /**
         * adminsのみ変更可能
         * @param {string} groupID 
         * @param {RequestGroup} requestGroup グループの追加
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(groupID: string, requestGroup: RequestGroup, options?: any): AxiosPromise<ResponseGroup> {
            return localVarFp.updateGroup(groupID, requestGroup, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * 自分をメンバーに追加する
     * @summary 自分を追加。open=true
     * @param {string} groupID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public addMeToGroup(groupID: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).addMeToGroup(groupID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * グループを作成します。traQのグループとは無関係です。
     * @summary グループ作成
     * @param {RequestGroup} requestGroup グループの追加
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public createGroup(requestGroup: RequestGroup, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).createGroup(requestGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * グループの削除
     * @summary Delete group
     * @param {string} groupID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteGroup(groupID: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteGroup(groupID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 自分しか削除出来ない。open=true
     * @summary 自分しか削除出来ない。open=true
     * @param {string} groupID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteMeFromGroup(groupID: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteMeFromGroup(groupID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 一件取得
     * @summary 一件取得
     * @param {string} groupID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroup(groupID: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroup(groupID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * すべてのグループを取得する
     * @summary グループを全て取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroups(options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 自分の所属しているグループのIDを返す
     * @param {'admins' | 'belongs' | 'attendees'} [relation] どのような関係性でユーザーと結びつけるか。| 取り得る値は、admins(ユーザーが管理者), belongs(ユーザーが所属している) | イベントはさらに、attendees(not absent)| 値がない場合は、belongs として振る舞う
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getMyGroups(relation?: 'admins' | 'belongs' | 'attendees', options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getMyGroups(relation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ユーザーが所属しているグループのIDを返す
     * @param {string} userID 
     * @param {'admins' | 'belongs' | 'attendees'} [relation] どのような関係性でユーザーと結びつけるか。| 取り得る値は、admins(ユーザーが管理者), belongs(ユーザーが所属している) | イベントはさらに、attendees(not absent)| 値がない場合は、belongs として振る舞う
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getUserGroups(userID: string, relation?: 'admins' | 'belongs' | 'attendees', options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getUserGroups(userID, relation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * adminsのみ変更可能
     * @param {string} groupID 
     * @param {RequestGroup} requestGroup グループの追加
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public updateGroup(groupID: string, requestGroup: RequestGroup, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).updateGroup(groupID, requestGroup, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ICalApi - axios parameter creator
 * @export
 */
export const ICalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Icalを取得
         * @param {string} icalToken 
         * @param {string} [q] Syntax: &lt;br&gt; top  : ε | expr, expr : term ( ( \&quot;||\&quot; | \&quot;&amp;&amp;\&quot; ) term)*&lt;br&gt; term : cmp | \&quot;(\&quot; expr \&quot;)\&quot;&lt;br&gt; cmp  : Attr ( \&quot;&#x3D;&#x3D;\&quot; | \&quot;!&#x3D;\&quot; ) UUID&lt;br&gt; Attr : \&quot;event\&quot; | \&quot;user\&quot; | \&quot;group\&quot; | \&quot;tag\&quot; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIcal: async (icalToken: string, q?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'icalToken' is not null or undefined
            assertParamExists('getIcal', 'icalToken', icalToken)
            const localVarPath = `/ical/v1/{icalToken}`
                .replace(`{${"icalToken"}}`, encodeURIComponent(String(icalToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * /ical で使う`secret`を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIcalSecret: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me/ical`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * /ical で使う`secret`を再生成
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetIcalSecret: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me/ical`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ICalApi - functional programming interface
 * @export
 */
export const ICalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ICalApiAxiosParamCreator(configuration)
    return {
        /**
         * Icalを取得
         * @param {string} icalToken 
         * @param {string} [q] Syntax: &lt;br&gt; top  : ε | expr, expr : term ( ( \&quot;||\&quot; | \&quot;&amp;&amp;\&quot; ) term)*&lt;br&gt; term : cmp | \&quot;(\&quot; expr \&quot;)\&quot;&lt;br&gt; cmp  : Attr ( \&quot;&#x3D;&#x3D;\&quot; | \&quot;!&#x3D;\&quot; ) UUID&lt;br&gt; Attr : \&quot;event\&quot; | \&quot;user\&quot; | \&quot;group\&quot; | \&quot;tag\&quot; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIcal(icalToken: string, q?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIcal(icalToken, q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * /ical で使う`secret`を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIcalSecret(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IcalSecret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIcalSecret(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * /ical で使う`secret`を再生成
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetIcalSecret(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IcalSecret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetIcalSecret(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ICalApi - factory interface
 * @export
 */
export const ICalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ICalApiFp(configuration)
    return {
        /**
         * Icalを取得
         * @param {string} icalToken 
         * @param {string} [q] Syntax: &lt;br&gt; top  : ε | expr, expr : term ( ( \&quot;||\&quot; | \&quot;&amp;&amp;\&quot; ) term)*&lt;br&gt; term : cmp | \&quot;(\&quot; expr \&quot;)\&quot;&lt;br&gt; cmp  : Attr ( \&quot;&#x3D;&#x3D;\&quot; | \&quot;!&#x3D;\&quot; ) UUID&lt;br&gt; Attr : \&quot;event\&quot; | \&quot;user\&quot; | \&quot;group\&quot; | \&quot;tag\&quot; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIcal(icalToken: string, q?: string, options?: any): AxiosPromise<string> {
            return localVarFp.getIcal(icalToken, q, options).then((request) => request(axios, basePath));
        },
        /**
         * /ical で使う`secret`を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIcalSecret(options?: any): AxiosPromise<IcalSecret> {
            return localVarFp.getIcalSecret(options).then((request) => request(axios, basePath));
        },
        /**
         * /ical で使う`secret`を再生成
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetIcalSecret(options?: any): AxiosPromise<IcalSecret> {
            return localVarFp.resetIcalSecret(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ICalApi - object-oriented interface
 * @export
 * @class ICalApi
 * @extends {BaseAPI}
 */
export class ICalApi extends BaseAPI {
    /**
     * Icalを取得
     * @param {string} icalToken 
     * @param {string} [q] Syntax: &lt;br&gt; top  : ε | expr, expr : term ( ( \&quot;||\&quot; | \&quot;&amp;&amp;\&quot; ) term)*&lt;br&gt; term : cmp | \&quot;(\&quot; expr \&quot;)\&quot;&lt;br&gt; cmp  : Attr ( \&quot;&#x3D;&#x3D;\&quot; | \&quot;!&#x3D;\&quot; ) UUID&lt;br&gt; Attr : \&quot;event\&quot; | \&quot;user\&quot; | \&quot;group\&quot; | \&quot;tag\&quot; 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ICalApi
     */
    public getIcal(icalToken: string, q?: string, options?: AxiosRequestConfig) {
        return ICalApiFp(this.configuration).getIcal(icalToken, q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * /ical で使う`secret`を取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ICalApi
     */
    public getIcalSecret(options?: AxiosRequestConfig) {
        return ICalApiFp(this.configuration).getIcalSecret(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * /ical で使う`secret`を再生成
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ICalApi
     */
    public resetIcalSecret(options?: AxiosRequestConfig) {
        return ICalApiFp(this.configuration).resetIcalSecret(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PublicApi - axios parameter creator
 * @export
 */
export const PublicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * リクエストに必要な情報を返す
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authParams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * version情報を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicApi - functional programming interface
 * @export
 */
export const PublicApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicApiAxiosParamCreator(configuration)
    return {
        /**
         * リクエストに必要な情報を返す
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthParams(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthParams>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * version情報を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersion(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetVersion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersion(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PublicApi - factory interface
 * @export
 */
export const PublicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicApiFp(configuration)
    return {
        /**
         * リクエストに必要な情報を返す
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthParams(options?: any): AxiosPromise<AuthParams> {
            return localVarFp.getAuthParams(options).then((request) => request(axios, basePath));
        },
        /**
         * version情報を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(options?: any): AxiosPromise<GetVersion200Response> {
            return localVarFp.getVersion(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublicApi - object-oriented interface
 * @export
 * @class PublicApi
 * @extends {BaseAPI}
 */
export class PublicApi extends BaseAPI {
    /**
     * リクエストに必要な情報を返す
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getAuthParams(options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getAuthParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * version情報を取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getVersion(options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getVersion(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RoomsApi - axios parameter creator
 * @export
 */
export const RoomsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 特権が必要。
         * @summary traPで確保した部屋の情報追加
         * @param {Array<AddAllRoomsRequestInner>} addAllRoomsRequestInner 進捗部屋情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAllRooms: async (addAllRoomsRequestInner: Array<AddAllRoomsRequestInner>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addAllRoomsRequestInner' is not null or undefined
            assertParamExists('addAllRooms', 'addAllRoomsRequestInner', addAllRoomsRequestInner)
            const localVarPath = `/rooms/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'text/csv';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addAllRoomsRequestInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 部屋の情報追加
         * @summary 部屋の情報追加
         * @param {RequestRoom} requestRoom 部屋の追加
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRooms: async (requestRoom: RequestRoom, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestRoom' is not null or undefined
            assertParamExists('addRooms', 'requestRoom', requestRoom)
            const localVarPath = `/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestRoom, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (関連する予約を削除する) エラーを出して削除を促す予定
         * @summary 部屋の情報を削除
         * @param {string} roomID 
         * @param {string} [excludeEventID] 除外するイベントのID。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoom: async (roomID: string, excludeEventID?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('deleteRoom', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (excludeEventID !== undefined) {
                localVarQueryParameter['excludeEventID'] = excludeEventID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 一件取得する
         * @summary 一件取得する
         * @param {string} roomID 
         * @param {string} [excludeEventID] 除外するイベントのID。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoom: async (roomID: string, excludeEventID?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('getRoom', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (excludeEventID !== undefined) {
                localVarQueryParameter['excludeEventID'] = excludeEventID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 進捗部屋の情報を取得
         * @summary 進捗部屋の情報を取得
         * @param {string} [dateBegin] 特定の日時から。
         * @param {string} [dateEnd] 特定の日時まで。
         * @param {string} [excludeEventID] 除外するイベントのID。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRooms: async (dateBegin?: string, dateEnd?: string, excludeEventID?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dateBegin !== undefined) {
                localVarQueryParameter['dateBegin'] = dateBegin;
            }

            if (dateEnd !== undefined) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (excludeEventID !== undefined) {
                localVarQueryParameter['excludeEventID'] = excludeEventID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 特権が必要。部屋が使用できることの確認を取り消す。
         * @summary 部屋を未確認にする
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unverifyRoom: async (roomID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('unverifyRoom', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/verified`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 特権が必要。部屋が使用できることを確認する
         * @summary 部屋を確認する
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyRoom: async (roomID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('verifyRoom', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/verified`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomsApi - functional programming interface
 * @export
 */
export const RoomsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoomsApiAxiosParamCreator(configuration)
    return {
        /**
         * 特権が必要。
         * @summary traPで確保した部屋の情報追加
         * @param {Array<AddAllRoomsRequestInner>} addAllRoomsRequestInner 進捗部屋情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAllRooms(addAllRoomsRequestInner: Array<AddAllRoomsRequestInner>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResponseRoom>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAllRooms(addAllRoomsRequestInner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 部屋の情報追加
         * @summary 部屋の情報追加
         * @param {RequestRoom} requestRoom 部屋の追加
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addRooms(requestRoom: RequestRoom, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseRoom>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addRooms(requestRoom, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (関連する予約を削除する) エラーを出して削除を促す予定
         * @summary 部屋の情報を削除
         * @param {string} roomID 
         * @param {string} [excludeEventID] 除外するイベントのID。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoom(roomID: string, excludeEventID?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoom(roomID, excludeEventID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 一件取得する
         * @summary 一件取得する
         * @param {string} roomID 
         * @param {string} [excludeEventID] 除外するイベントのID。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoom(roomID: string, excludeEventID?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseRoom>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoom(roomID, excludeEventID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 進捗部屋の情報を取得
         * @summary 進捗部屋の情報を取得
         * @param {string} [dateBegin] 特定の日時から。
         * @param {string} [dateEnd] 特定の日時まで。
         * @param {string} [excludeEventID] 除外するイベントのID。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRooms(dateBegin?: string, dateEnd?: string, excludeEventID?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResponseRoom>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRooms(dateBegin, dateEnd, excludeEventID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 特権が必要。部屋が使用できることの確認を取り消す。
         * @summary 部屋を未確認にする
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unverifyRoom(roomID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unverifyRoom(roomID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 特権が必要。部屋が使用できることを確認する
         * @summary 部屋を確認する
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyRoom(roomID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyRoom(roomID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RoomsApi - factory interface
 * @export
 */
export const RoomsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoomsApiFp(configuration)
    return {
        /**
         * 特権が必要。
         * @summary traPで確保した部屋の情報追加
         * @param {Array<AddAllRoomsRequestInner>} addAllRoomsRequestInner 進捗部屋情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAllRooms(addAllRoomsRequestInner: Array<AddAllRoomsRequestInner>, options?: any): AxiosPromise<Array<ResponseRoom>> {
            return localVarFp.addAllRooms(addAllRoomsRequestInner, options).then((request) => request(axios, basePath));
        },
        /**
         * 部屋の情報追加
         * @summary 部屋の情報追加
         * @param {RequestRoom} requestRoom 部屋の追加
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRooms(requestRoom: RequestRoom, options?: any): AxiosPromise<ResponseRoom> {
            return localVarFp.addRooms(requestRoom, options).then((request) => request(axios, basePath));
        },
        /**
         * (関連する予約を削除する) エラーを出して削除を促す予定
         * @summary 部屋の情報を削除
         * @param {string} roomID 
         * @param {string} [excludeEventID] 除外するイベントのID。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoom(roomID: string, excludeEventID?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRoom(roomID, excludeEventID, options).then((request) => request(axios, basePath));
        },
        /**
         * 一件取得する
         * @summary 一件取得する
         * @param {string} roomID 
         * @param {string} [excludeEventID] 除外するイベントのID。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoom(roomID: string, excludeEventID?: string, options?: any): AxiosPromise<ResponseRoom> {
            return localVarFp.getRoom(roomID, excludeEventID, options).then((request) => request(axios, basePath));
        },
        /**
         * 進捗部屋の情報を取得
         * @summary 進捗部屋の情報を取得
         * @param {string} [dateBegin] 特定の日時から。
         * @param {string} [dateEnd] 特定の日時まで。
         * @param {string} [excludeEventID] 除外するイベントのID。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRooms(dateBegin?: string, dateEnd?: string, excludeEventID?: string, options?: any): AxiosPromise<Array<ResponseRoom>> {
            return localVarFp.getRooms(dateBegin, dateEnd, excludeEventID, options).then((request) => request(axios, basePath));
        },
        /**
         * 特権が必要。部屋が使用できることの確認を取り消す。
         * @summary 部屋を未確認にする
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unverifyRoom(roomID: string, options?: any): AxiosPromise<void> {
            return localVarFp.unverifyRoom(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 特権が必要。部屋が使用できることを確認する
         * @summary 部屋を確認する
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyRoom(roomID: string, options?: any): AxiosPromise<void> {
            return localVarFp.verifyRoom(roomID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomsApi - object-oriented interface
 * @export
 * @class RoomsApi
 * @extends {BaseAPI}
 */
export class RoomsApi extends BaseAPI {
    /**
     * 特権が必要。
     * @summary traPで確保した部屋の情報追加
     * @param {Array<AddAllRoomsRequestInner>} addAllRoomsRequestInner 進捗部屋情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public addAllRooms(addAllRoomsRequestInner: Array<AddAllRoomsRequestInner>, options?: AxiosRequestConfig) {
        return RoomsApiFp(this.configuration).addAllRooms(addAllRoomsRequestInner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 部屋の情報追加
     * @summary 部屋の情報追加
     * @param {RequestRoom} requestRoom 部屋の追加
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public addRooms(requestRoom: RequestRoom, options?: AxiosRequestConfig) {
        return RoomsApiFp(this.configuration).addRooms(requestRoom, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * (関連する予約を削除する) エラーを出して削除を促す予定
     * @summary 部屋の情報を削除
     * @param {string} roomID 
     * @param {string} [excludeEventID] 除外するイベントのID。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public deleteRoom(roomID: string, excludeEventID?: string, options?: AxiosRequestConfig) {
        return RoomsApiFp(this.configuration).deleteRoom(roomID, excludeEventID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 一件取得する
     * @summary 一件取得する
     * @param {string} roomID 
     * @param {string} [excludeEventID] 除外するイベントのID。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getRoom(roomID: string, excludeEventID?: string, options?: AxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getRoom(roomID, excludeEventID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 進捗部屋の情報を取得
     * @summary 進捗部屋の情報を取得
     * @param {string} [dateBegin] 特定の日時から。
     * @param {string} [dateEnd] 特定の日時まで。
     * @param {string} [excludeEventID] 除外するイベントのID。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getRooms(dateBegin?: string, dateEnd?: string, excludeEventID?: string, options?: AxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getRooms(dateBegin, dateEnd, excludeEventID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 特権が必要。部屋が使用できることの確認を取り消す。
     * @summary 部屋を未確認にする
     * @param {string} roomID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public unverifyRoom(roomID: string, options?: AxiosRequestConfig) {
        return RoomsApiFp(this.configuration).unverifyRoom(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 特権が必要。部屋が使用できることを確認する
     * @summary 部屋を確認する
     * @param {string} roomID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public verifyRoom(roomID: string, options?: AxiosRequestConfig) {
        return RoomsApiFp(this.configuration).verifyRoom(roomID, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * タグを全て取得
         * @summary タグを全て取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * すでにある場合は、error
         * @summary タグを作成。
         * @param {RequestTag} requestTag タグ自体の追加
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTag: async (requestTag: RequestTag, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestTag' is not null or undefined
            assertParamExists('postTag', 'requestTag', requestTag)
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestTag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * タグを全て取得
         * @summary タグを全て取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTag(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResponseTag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTag(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * すでにある場合は、error
         * @summary タグを作成。
         * @param {RequestTag} requestTag タグ自体の追加
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTag(requestTag: RequestTag, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTag(requestTag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * タグを全て取得
         * @summary タグを全て取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag(options?: any): AxiosPromise<Array<ResponseTag>> {
            return localVarFp.getTag(options).then((request) => request(axios, basePath));
        },
        /**
         * すでにある場合は、error
         * @summary タグを作成。
         * @param {RequestTag} requestTag タグ自体の追加
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTag(requestTag: RequestTag, options?: any): AxiosPromise<ResponseTag> {
            return localVarFp.postTag(requestTag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * タグを全て取得
     * @summary タグを全て取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTag(options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).getTag(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * すでにある場合は、error
     * @summary タグを作成。
     * @param {RequestTag} requestTag タグ自体の追加
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public postTag(requestTag: RequestTag, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).postTag(requestTag, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * /ical で使う`secret`を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIcalSecret: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me/ical`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のユーザー情報を取得
         * @summary 自分のユーザー情報を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザー一覧を返す
         * @param {boolean} [includeSuspended] アカウントがアクティブでないユーザーを含めるかどうか。 | traQ由来のquery。 | de
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (includeSuspended?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeSuspended !== undefined) {
                localVarQueryParameter['include-suspended'] = includeSuspended;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * /ical で使う`secret`を再生成
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetIcalSecret: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me/ical`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 管理者権限が必要。 traQのuserと同期します。 存在していないユーザーは作成されます。 stateが同期されます。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncUsers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * /ical で使う`secret`を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIcalSecret(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IcalSecret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIcalSecret(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 自分のユーザー情報を取得
         * @summary 自分のユーザー情報を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMe(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMe(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ユーザー一覧を返す
         * @param {boolean} [includeSuspended] アカウントがアクティブでないユーザーを含めるかどうか。 | traQ由来のquery。 | de
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(includeSuspended?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResponseUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(includeSuspended, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * /ical で使う`secret`を再生成
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetIcalSecret(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IcalSecret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetIcalSecret(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 管理者権限が必要。 traQのuserと同期します。 存在していないユーザーは作成されます。 stateが同期されます。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncUsers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * /ical で使う`secret`を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIcalSecret(options?: any): AxiosPromise<IcalSecret> {
            return localVarFp.getIcalSecret(options).then((request) => request(axios, basePath));
        },
        /**
         * 自分のユーザー情報を取得
         * @summary 自分のユーザー情報を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: any): AxiosPromise<ResponseUser> {
            return localVarFp.getMe(options).then((request) => request(axios, basePath));
        },
        /**
         * ユーザー一覧を返す
         * @param {boolean} [includeSuspended] アカウントがアクティブでないユーザーを含めるかどうか。 | traQ由来のquery。 | de
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(includeSuspended?: boolean, options?: any): AxiosPromise<Array<ResponseUser>> {
            return localVarFp.getUsers(includeSuspended, options).then((request) => request(axios, basePath));
        },
        /**
         * /ical で使う`secret`を再生成
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetIcalSecret(options?: any): AxiosPromise<IcalSecret> {
            return localVarFp.resetIcalSecret(options).then((request) => request(axios, basePath));
        },
        /**
         * 管理者権限が必要。 traQのuserと同期します。 存在していないユーザーは作成されます。 stateが同期されます。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncUsers(options?: any): AxiosPromise<void> {
            return localVarFp.syncUsers(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * /ical で使う`secret`を取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getIcalSecret(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getIcalSecret(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 自分のユーザー情報を取得
     * @summary 自分のユーザー情報を取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getMe(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ユーザー一覧を返す
     * @param {boolean} [includeSuspended] アカウントがアクティブでないユーザーを含めるかどうか。 | traQ由来のquery。 | de
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(includeSuspended?: boolean, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsers(includeSuspended, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * /ical で使う`secret`を再生成
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public resetIcalSecret(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).resetIcalSecret(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 管理者権限が必要。 traQのuserと同期します。 存在していないユーザーは作成されます。 stateが同期されます。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public syncUsers(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).syncUsers(options).then((request) => request(this.axios, this.basePath));
    }
}


